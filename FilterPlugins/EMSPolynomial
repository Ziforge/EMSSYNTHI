classdef RealTimeDAFXFilter < audioPlugin
    properties
        Cutoff = 1000;  % Hz
        Resonance = 0.7; % Q Factor
        Gain = 6; % dB
        OversamplingFactor = 32; % ðŸ”„ 32x Oversampling for Ultra-Clean Filtering
    end

    properties (Access = private)
        fs; % Sampling Rate
        fsOS; % Oversampled Sampling Rate
        crossfadeAlpha = 0.15; % ðŸ”„ Crossfade for smoother transitions
        smoothingFactor = 0.1; % ðŸŽšï¸ Smoothing factor for coefficients
        bCurrent = [1, 0, 0]; % âœ… Properly initialized Numerator coefficients
        aCurrent = [1, 0, 0]; % âœ… Properly initialized Denominator coefficients
        lpFilter; % ðŸ”§ Linear-Phase FIR Lowpass Filter
        
        % Graphing Variables
        fig; % Figure handle for visualization
        plotHandle; % Plot line handle
        graphEnabled = false; % Internal flag (NOT visible in UI)
    end

    properties (Constant)
        PluginInterface = audioPluginInterface( ...
            audioPluginParameter('Cutoff', 'DisplayName', 'Cutoff Frequency', 'Mapping', {'log', 20, 20000}, 'Style', 'rotary', 'Layout', [1,1]), ...
            audioPluginParameter('Resonance', 'DisplayName', 'Resonance (Q)', 'Mapping', {'lin', 0.1, 10}, 'Style', 'rotary', 'Layout', [1,2]), ...
            audioPluginParameter('Gain', 'DisplayName', 'Gain (dB)', 'Mapping', {'lin', -12, 12}, 'Style', 'rotary', 'Layout', [1,3]) ...
        );
    end

    methods
        function obj = RealTimeDAFXFilter()
            obj.fs = getSampleRate(obj); % Ensure correct sample rate
            obj.fsOS = obj.fs * obj.OversamplingFactor; % 32x Oversampled Rate
            obj.createDAFXFilter();
            obj.createDownsamplingFilter();
        end

        function audioOut = process(obj, audioIn)
            % **Step 1: Oversample (32x Upsampling)**
            upsampleFactor = obj.OversamplingFactor;
            audioInOS = resample(audioIn, upsampleFactor, 1, 10); % Polyphase Filtering

            % **Step 2: Process the Filter at the Higher Sample Rate**
            audioOutOld = filter(obj.bCurrent, obj.aCurrent, audioInOS);
            audioOutNew = filter(obj.bCurrent, obj.aCurrent, audioInOS);

            % **Step 3: Smooth Transition Between Old & New Filter**
            alpha = obj.crossfadeAlpha;
            filteredAudio = (1 - alpha) * audioOutOld + alpha * audioOutNew;

            % **Step 4: Apply a High-Quality Linear-Phase FIR Lowpass Filter**
            filteredAudio = fftfilt(obj.lpFilter, filteredAudio); % FFT-based FIR Filtering

            % **Step 5: Downsample Back to Original Rate**
            audioOut = resample(filteredAudio, 1, upsampleFactor, 10);

            % **Step 6: Stability Check (Prevent NaN/Inf Issues)**
            if any(isnan(audioOut(:))) || any(isinf(audioOut(:)))
                warning('Audio output contains NaN or Inf! Resetting to zeros.');
                audioOut = zeros(size(audioOut)); % Silence unstable values
            end

            % ðŸ”¥ Automatically enable graph in MATLAB (but NOT in DAWs)
            if ~obj.graphEnabled && isMATLAB()
                obj.initializeGraph();
                obj.graphEnabled = true;
            end

            % ðŸ”¥ Update graph dynamically
            if obj.graphEnabled
                obj.updateGraph(audioOut);
            end
        end

        function reset(obj)
            obj.fs = getSampleRate(obj); % Ensure correct sample rate on reset
            obj.createDAFXFilter();
            obj.createDownsamplingFilter();
        end

        function set.Cutoff(obj, value)
            obj.Cutoff = value;
            obj.createDAFXFilter();
        end

        function set.Resonance(obj, value)
            obj.Resonance = value;
            obj.createDAFXFilter();
        end

        function set.Gain(obj, value)
            obj.Gain = value;
            obj.createDAFXFilter();
        end
    end

    methods (Access = private)
        function createDAFXFilter(obj)
            % **ðŸ› ï¸ Step 1: Adjust for Oversampled Sample Rate**
            fsOS = obj.fs * obj.OversamplingFactor; % Use oversampled rate

            % **Pre-Warp Cutoff Frequency to Avoid Warping Artifacts**
            warpedOmega = (2 * fsOS) * tan(pi * obj.Cutoff / fsOS);
            omega = 2 * pi * warpedOmega / fsOS;

            alpha = sin(omega) / (2 * obj.Resonance);
            A = 10^(obj.Gain / 40);

            % **ðŸ› ï¸ Step 2: Compute Bilinear Transformed Filter Coefficients**
            b0 = (1 - cos(omega)) / 2;
            b1 = 1 - cos(omega);
            b2 = (1 - cos(omega)) / 2;
            a0 = 1 + alpha;
            a1 = -2 * cos(omega);
            a2 = 1 - alpha;

            % **ðŸ› ï¸ Step 3: Normalize Coefficients**
            bNew = [b0, b1, b2] / a0;
            aNew = [1, a1 / a0, a2 / a0];

            % **ðŸ› ï¸ Step 4: Apply Exponential Smoothing**
            smoothing = obj.smoothingFactor;
            obj.bCurrent = smoothing * bNew + (1 - smoothing) * obj.bCurrent;
            obj.aCurrent = smoothing * aNew + (1 - smoothing) * obj.aCurrent;
        end

        function createDownsamplingFilter(obj)
            % **ðŸ”§ Step 6: Create a High-Precision Linear-Phase Downsampling Filter**
            N = 120;  % High Order FIR Filter for Steep Transition
            fc = 0.2;  % Lower the cutoff frequency to 0.2 Nyquist
            obj.lpFilter = fir1(N, fc, 'low', kaiser(N+1, 8));  % Linear-Phase FIR Filter
        end
        
        % ðŸ”¥ Graphing Functions
        function initializeGraph(obj)
            if isempty(obj.fig) || ~isvalid(obj.fig)
                obj.fig = figure('Name', 'RealTimeDAFXFilter Visualization', ...
                                 'NumberTitle', 'off', ...
                                 'Position', [100, 100, 600, 300]);
                obj.plotHandle = plot(nan, nan, 'r', 'LineWidth', 2);
                xlabel('Time (samples)');
                ylabel('Amplitude');
                title('Filter Output Movement');
                grid on;
                xlim([0, 1024]);
                ylim([-1, 1]);
            end
        end

        function updateGraph(obj, signal)
            if isvalid(obj.fig)
                set(obj.plotHandle, 'YData', signal(1:min(1024, length(signal))), ...
                                    'XData', 1:min(1024, length(signal)));
                drawnow limitrate;
            end
        end
    end
end

function flag = isMATLAB()
    % Helper function: Check if running inside MATLAB (not as a VST/AU)
    flag = ~isdeployed && usejava('jvm');
end
